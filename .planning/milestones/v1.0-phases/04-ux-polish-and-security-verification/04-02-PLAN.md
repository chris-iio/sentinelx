---
phase: 04-ux-polish-and-security-verification
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_security_audit.py
autonomous: true
requirements:
  - UI-06

must_haves:
  truths:
    - "CSP header is confirmed as 'default-src 'self'; script-src 'self'' via automated test"
    - "Zero uses of |safe filter on any template confirmed via automated test"
    - "Zero outbound HTTP calls where the URL is constructed from an IOC value confirmed via automated test"
    - "All security audit checks pass as automated pytest assertions"
  artifacts:
    - path: "tests/test_security_audit.py"
      provides: "Automated security posture verification tests"
      contains: "test_csp_header_exact_match"
  key_links:
    - from: "tests/test_security_audit.py"
      to: "app/__init__.py"
      via: "Flask test client checking response headers"
      pattern: "Content-Security-Policy"
    - from: "tests/test_security_audit.py"
      to: "app/templates/"
      via: "File scanning for |safe filter usage"
      pattern: "safe"
---

<objective>
Create automated security audit tests that verify the application's security posture before shipping: CSP header correctness, template safety (no |safe on untrusted data), and HTTP safety (no IOC values used as URL components).

Purpose: Provides automated, repeatable confirmation of the security properties listed in Phase 4 success criteria. These tests guard against regressions in future development. While the security posture is already correct (confirmed by research), codifying it as tests makes the verification permanent.

Output: tests/test_security_audit.py with 3 automated security audit tests.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ux-polish-and-security-verification/04-RESEARCH.md

Key existing code to reference:
@app/__init__.py (CSP header set in after_request)
@app/templates/ (template directory to scan)
@app/enrichment/adapters/ (adapter directory to scan for URL safety)
@tests/conftest.py (existing fixtures: app, client)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create security audit test file with CSP, template safety, and HTTP safety tests</name>
  <files>tests/test_security_audit.py</files>
  <action>
Create a new test file `tests/test_security_audit.py` with three automated security audit tests. Use the existing `client` fixture from `conftest.py` for the CSP test. Use pathlib for file scanning tests (no subprocess).

```python
"""Security audit tests for shipping verification.

These tests codify the security properties from Phase 4 success criteria:
1. CSP header blocks inline scripts
2. No |safe filter on untrusted data in templates
3. No outbound HTTP calls with IOC values as URL components

These are regression guards — the codebase already passes all checks.
"""
import re
from pathlib import Path

APP_ROOT = Path(__file__).parent.parent / "app"
TEMPLATES_DIR = APP_ROOT / "templates"
ADAPTERS_DIR = APP_ROOT / "enrichment" / "adapters"


def test_csp_header_exact_match(client):
    """CSP must be 'default-src 'self'; script-src 'self'' — blocks inline scripts."""
    response = client.get("/")
    assert "Content-Security-Policy" in response.headers
    csp = response.headers["Content-Security-Policy"]
    assert "default-src 'self'" in csp
    assert "script-src 'self'" in csp
    # Ensure no unsafe-inline or unsafe-eval
    assert "unsafe-inline" not in csp
    assert "unsafe-eval" not in csp


def test_no_safe_filter_in_templates():
    """No Jinja2 |safe filter usage in any template file.

    |safe disables autoescaping — any use on untrusted data (IOC values,
    API responses) creates an XSS vector (SEC-08).

    Note: | upper, | length, etc. are safe and must NOT be flagged.
    The regex specifically matches '| safe' or '|safe' (the filter name).
    """
    safe_pattern = re.compile(r"\|\s*safe\b")
    violations = []

    for template_file in TEMPLATES_DIR.rglob("*.html"):
        content = template_file.read_text()
        for line_no, line in enumerate(content.splitlines(), start=1):
            if safe_pattern.search(line):
                violations.append(f"{template_file.name}:{line_no}: {line.strip()}")

    assert violations == [], (
        f"Found |safe filter in templates (XSS risk):\n"
        + "\n".join(violations)
    )


def test_no_ioc_value_in_outbound_url():
    """No outbound HTTP call constructs its URL from an IOC value.

    IOC values must only appear as POST body data, query parameters, or
    base64-encoded path segments (VT URL lookup). Direct string
    interpolation of IOC values into URL paths is an SSRF vector (SEC-07).

    Scanning strategy: look for patterns where ioc.value or ioc_value
    appears in URL string construction (f-string, .format, or + concat
    with 'http'). Exclude known-safe patterns:
    - base64 encoding (VT _url_id)
    - POST body / json= / data= parameters
    - hash= / search_term= query parameters
    """
    # Patterns that indicate IOC value used in URL construction (unsafe)
    unsafe_patterns = [
        # f-string with ioc in URL
        re.compile(r'f["\']https?://.*\{.*ioc', re.IGNORECASE),
        # .format() with ioc in URL
        re.compile(r'["\']https?://.*\.format\(.*ioc', re.IGNORECASE),
        # String concat: "http..." + ioc_value or + ioc.value
        re.compile(r'["\']https?://[^"\']*["\']\s*\+\s*(?:ioc[._]value|ioc\.value)', re.IGNORECASE),
    ]

    # Known-safe patterns to exclude (VT base64 URL ID)
    safe_exclusions = [
        re.compile(r'base64'),
        re.compile(r'_url_id'),
    ]

    violations = []

    for adapter_file in ADAPTERS_DIR.rglob("*.py"):
        content = adapter_file.read_text()
        for line_no, line in enumerate(content.splitlines(), start=1):
            for pattern in unsafe_patterns:
                if pattern.search(line):
                    # Check if line matches a known-safe exclusion
                    is_safe = any(exc.search(line) for exc in safe_exclusions)
                    if not is_safe:
                        violations.append(
                            f"{adapter_file.name}:{line_no}: {line.strip()}"
                        )

    assert violations == [], (
        f"Found IOC value used in URL construction (SSRF risk):\n"
        + "\n".join(violations)
    )
```

Key design decisions:
- Uses pathlib for file scanning (no subprocess, no shell) — clean Python.
- `test_csp_header_exact_match` uses the Flask test client to make a real request and check headers — tests the actual middleware.
- `test_no_safe_filter_in_templates` uses a regex that matches `|safe` or `| safe` but NOT `| upper` or other filters. The `\b` word boundary prevents false positives.
- `test_no_ioc_value_in_outbound_url` scans adapter files for unsafe URL construction patterns while explicitly excluding the known-safe VT base64 pattern.
- All three tests produce clear violation messages if they fail, showing exact file:line:content.
  </action>
  <verify>
    <automated>cd /home/chris/projects/sentinelx && python -m pytest tests/test_security_audit.py -v 2>&1 | tail -15</automated>
    <manual>All 3 tests should pass (green). The codebase is already clean.</manual>
  </verify>
  <done>
    - test_csp_header_exact_match passes: CSP is "default-src 'self'; script-src 'self'" with no unsafe-inline/unsafe-eval
    - test_no_safe_filter_in_templates passes: zero |safe usages found in templates
    - test_no_ioc_value_in_outbound_url passes: no unsafe IOC-to-URL construction in adapters
    - All tests produce clear failure messages showing file:line if a violation is introduced in the future
  </done>
</task>

</tasks>

<verification>
- [ ] `python -m pytest tests/test_security_audit.py -v` — all 3 tests pass
- [ ] `python -m pytest tests/ -x -q` — full test suite still passes (no regressions)
- [ ] CSP test checks for absence of unsafe-inline and unsafe-eval
- [ ] Template scan uses correct regex that won't false-positive on | upper
- [ ] URL safety scan correctly excludes VT base64 pattern
</verification>

<success_criteria>
All three Phase 4 security success criteria are codified as automated tests that pass and will catch future regressions: CSP header correctness, template safety, and HTTP safety.
</success_criteria>

<output>
After completion, create `.planning/phases/04-ux-polish-and-security-verification/04-02-SUMMARY.md`
</output>
