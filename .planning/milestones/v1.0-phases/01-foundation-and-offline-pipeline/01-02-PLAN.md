---
phase: 01-foundation-and-offline-pipeline
plan: 02
type: tdd
wave: 2
depends_on:
  - "01-01"
files_modified:
  - app/pipeline/normalizer.py
  - app/pipeline/classifier.py
  - tests/test_normalizer.py
  - tests/test_classifier.py
autonomous: true
requirements:
  - EXTR-03
  - EXTR-04

must_haves:
  truths:
    - "All documented defanging patterns are correctly normalized to canonical form"
    - "Each IOC is classified by type using deterministic regex logic, no ML or heuristics"
    - "Classifier handles all 8 IOC types: IPv4, IPv6, domain, URL, MD5, SHA1, SHA256, CVE"
    - "Classification uses strict precedence ordering to avoid ambiguous matches"
  artifacts:
    - path: "app/pipeline/normalizer.py"
      provides: "Defanging normalization — refangs IOC strings to canonical form"
      exports: ["normalize"]
    - path: "app/pipeline/classifier.py"
      provides: "Deterministic IOC type classification from normalized strings"
      exports: ["classify"]
    - path: "tests/test_normalizer.py"
      provides: "30+ defanging variant test corpus"
      min_lines: 60
    - path: "tests/test_classifier.py"
      provides: "Type classification tests for all 8 IOC types"
      min_lines: 50
  key_links:
    - from: "app/pipeline/classifier.py"
      to: "app/pipeline/models.py"
      via: "IOCType enum and IOC dataclass import"
      pattern: "from.*models import IOCType, IOC"
    - from: "app/pipeline/classifier.py"
      to: "app/pipeline/normalizer.py"
      via: "May call normalize internally or expect pre-normalized input"
      pattern: "normalize"
---

<objective>
TDD implementation of IOC normalizer (defanging) and classifier (type detection).

Purpose: These are pure functions with well-defined I/O — perfect TDD candidates. The normalizer converts defanged IOC strings to canonical form. The classifier determines the IOC type from a normalized string using deterministic regex logic. Both are core to extraction accuracy and must handle edge cases rigorously.

Output: Working, tested normalizer and classifier with 80%+ coverage.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-offline-pipeline/01-RESEARCH.md
@.planning/phases/01-foundation-and-offline-pipeline/01-01-SUMMARY.md
</context>

<feature>
  <name>IOC Normalizer (Defanging)</name>
  <files>app/pipeline/normalizer.py, tests/test_normalizer.py</files>
  <behavior>
    The `normalize(text: str) -> str` function refangs a single defanged IOC string to its canonical form. It handles all common defanging patterns:

    Test corpus (minimum 30 variants):
    - `hxxp://example.com` -> `http://example.com`
    - `hxxps://example.com` -> `https://example.com`
    - `hXXp://example.com` -> `http://example.com` (mixed case)
    - `example[.]com` -> `example.com`
    - `example(.)com` -> `example.com`
    - `example{.}com` -> `example.com`
    - `example[dot]com` -> `example.com`
    - `example(dot)com` -> `example.com`
    - `example{dot}com` -> `example.com`
    - `example_dot_com` -> `example.com`
    - `user[@]example.com` -> `user@example.com`
    - `user[at]example.com` -> `user@example.com`
    - `user(@)example.com` -> `user@example.com`
    - `hxxp[://]example.com` -> `http://example.com`
    - `hxxps[://]example.com` -> `https://example.com`
    - `hxxp[:]//example.com` -> `http://example.com`
    - `192[.]168[.]1[.]1` -> `192.168.1.1`
    - `192(.)168(.)1(.)1` -> `192.168.1.1`
    - `hxxps://example[.]com/path` -> `https://example.com/path`
    - `hxxp://192[.]168[.]1[.]1:8080/test` -> `http://192.168.1.1:8080/test`
    - Already-clean input is returned unchanged: `192.168.1.1` -> `192.168.1.1`
    - Already-clean URL: `https://example.com` -> `https://example.com`
    - Multiple patterns combined: `hxxps://evil[.]example[dot]com` -> `https://evil.example.com`
    - Empty string returns empty string
    - Case insensitive: `HXXP://EXAMPLE[.]COM` -> `http://EXAMPLE.COM` (scheme lowercase, rest preserved)
    - `[://]` variant: `hxxps[://]example.com` -> `https://example.com`
    - `[:/]` variant: `http[:/]example.com` -> `http://example.com` (if encountered)

    Ordered by precedence — apply all patterns left to right. Use `re.sub` with compiled patterns for performance.
  </behavior>
  <implementation>
    After tests pass:
    - Module-level compiled regex list `DEFANG_PATTERNS` with `(pattern, replacement)` tuples
    - `normalize()` iterates patterns and applies `re.sub` sequentially
    - All patterns case-insensitive for scheme normalization
    - No side effects, no imports beyond `re`
  </implementation>
</feature>

<feature>
  <name>IOC Classifier (Type Detection)</name>
  <files>app/pipeline/classifier.py, tests/test_classifier.py</files>
  <behavior>
    The `classify(normalized_value: str, raw_match: str) -> IOC | None` function determines the IOC type from a normalized string using deterministic regex logic and returns a typed IOC dataclass, or None if the string cannot be classified.

    Classification precedence (strict ordering to avoid ambiguity):
    1. CVE — matches `CVE-\d{4}-\d{4,}` pattern
    2. SHA256 — exactly 64 hex characters
    3. SHA1 — exactly 40 hex characters
    4. MD5 — exactly 32 hex characters
    5. URL — starts with `http://` or `https://` and has valid structure
    6. IPv6 — valid IPv6 address (use `ipaddress.ip_address()` for validation)
    7. IPv4 — valid IPv4 address (use `ipaddress.ip_address()` for validation, reject if any octet > 255)
    8. Domain — contains at least one dot, valid hostname characters, has valid TLD

    Test cases per type:
    - IPv4: `192.168.1.1`, `10.0.0.1`, `8.8.8.8`; reject `999.999.999.999`, `192.168.1`
    - IPv6: `2001:0db8:85a3::8a2e:0370:7334`, `::1`, `fe80::1`; reject partial
    - Domain: `example.com`, `sub.example.co.uk`, `evil-domain.org`; reject `localhost`, bare TLDs
    - URL: `http://example.com`, `https://example.com/path?q=1`, `http://192.168.1.1:8080`
    - MD5: `d41d8cd98f00b204e9800998ecf8427e` (32 hex)
    - SHA1: `da39a3ee5e6b4b0d3255bfef95601890afd80709` (40 hex)
    - SHA256: `e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855` (64 hex)
    - CVE: `CVE-2024-12345`, `CVE-2025-49596`; reject `CVE-2024` (no ID)
    - None returned for: random text, numbers, empty string

    Important: A URL like `http://192.168.1.1` should classify as URL (not IPv4) due to precedence. A hash-length hex string that matches SHA256 length should be SHA256, not shorter hash types.
  </behavior>
  <implementation>
    After tests pass:
    - Import `IOCType`, `IOC` from `app.pipeline.models`
    - Import `ipaddress` for IP validation
    - Compiled regex patterns for each type
    - `classify()` checks patterns in precedence order, returns first match as `IOC(type=..., value=normalized_value, raw_match=raw_match)`
    - Returns `None` if no pattern matches
    - Pure function — no side effects, no network calls
  </implementation>
</feature>

<verification>
1. `pytest tests/test_normalizer.py -v` — all tests pass
2. `pytest tests/test_classifier.py -v` — all tests pass
3. `pytest tests/test_normalizer.py tests/test_classifier.py --cov=app/pipeline --cov-report=term-missing` — 80%+ coverage
4. Test corpus covers at least 30 defanging variants
5. All 8 IOC types have at least 2 positive test cases each
6. Edge cases tested: empty input, already-clean input, ambiguous inputs
</verification>

<success_criteria>
- Normalizer handles all documented defanging patterns correctly
- Classifier deterministically identifies all 8 IOC types
- Classification precedence prevents ambiguous matches
- 80%+ test coverage on normalizer and classifier
- All tests pass with `pytest -v`
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-offline-pipeline/01-02-SUMMARY.md`
</output>
