---
phase: 02-core-enrichment
plan: 02
type: tdd
wave: 2
depends_on: [02-01]
files_modified:
  - app/enrichment/orchestrator.py
  - tests/test_orchestrator.py
autonomous: true
requirements: [ENRC-04, ENRC-06]

must_haves:
  truths:
    - "All enrichable IOCs in a list are looked up in parallel, not sequentially"
    - "A failure in one IOC's enrichment does not block or crash other IOC results"
    - "Failed lookups are automatically retried once before returning an error"
    - "Job status tracks total, done count, results list, and complete flag"
    - "Job status is thread-safe (concurrent writes from worker threads don't corrupt state)"
  artifacts:
    - path: "app/enrichment/orchestrator.py"
      provides: "EnrichmentOrchestrator with ThreadPoolExecutor parallel execution"
      contains: "class EnrichmentOrchestrator"
    - path: "tests/test_orchestrator.py"
      provides: "Orchestrator unit tests with mocked adapter"
      min_lines: 60
  key_links:
    - from: "app/enrichment/orchestrator.py"
      to: "app/enrichment/adapters/virustotal.py"
      via: "calls adapter.lookup(ioc) per IOC"
      pattern: "adapter\\.lookup|_adapter\\.lookup"
    - from: "app/enrichment/orchestrator.py"
      to: "concurrent.futures"
      via: "ThreadPoolExecutor for parallel execution"
      pattern: "ThreadPoolExecutor"
---

<objective>
Build the enrichment orchestrator that fires VT lookups in parallel using ThreadPoolExecutor, tracks job progress in a thread-safe dict, and retries failed lookups once — using TDD to prove parallel execution, error isolation, and retry behavior.

Purpose: The orchestrator is the engine that turns "list of IOCs" into "list of enrichment results" concurrently. It must be proven correct under parallel execution before being wired into Flask routes (Plan 03).

Output: Tested EnrichmentOrchestrator with parallel execution, retry-once, per-IOC error isolation, and job status tracking.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Plan 01 outputs this plan depends on:
@app/enrichment/models.py (EnrichmentResult, EnrichmentError)
@app/enrichment/adapters/virustotal.py (VTAdapter interface — lookup(ioc) signature)
@app/pipeline/models.py (IOC, IOCType)
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED — Write failing tests for enrichment orchestrator</name>
  <files>
    app/enrichment/orchestrator.py
    tests/test_orchestrator.py
  </files>
  <action>
Create `app/enrichment/orchestrator.py` with a stub `EnrichmentOrchestrator` class (methods raise NotImplementedError).

**tests/test_orchestrator.py** — Write tests using a mock adapter (not the real VTAdapter):

Create a `MockAdapter` class or use `unittest.mock.MagicMock` that returns configurable EnrichmentResult/EnrichmentError per IOC.

Tests:
- `test_enrich_all_calls_lookup_for_each_enrichable_ioc`: Pass 3 IOCs (2 IPV4, 1 CVE). Verify adapter.lookup called exactly 2 times (CVE skipped — not in ENDPOINT_MAP).
- `test_enrich_all_parallel_execution`: Pass 5 IOCs. Mock adapter.lookup to sleep(0.5) then return result. Assert total wall-clock time < 3s (proves parallel, not sequential 2.5s). Use `time.monotonic()` for timing.
- `test_enrich_all_returns_all_results`: Pass 3 enrichable IOCs, mock all succeed. Verify job results list has exactly 3 EnrichmentResult items.
- `test_error_isolation`: Pass 3 IOCs, mock 2nd to return EnrichmentError. Verify job has 2 EnrichmentResult + 1 EnrichmentError — all 3 present, no crash.
- `test_retry_on_failure`: Mock adapter.lookup to return EnrichmentError on first call then EnrichmentResult on second call for same IOC. Verify final result is EnrichmentResult (retry succeeded). Verify adapter.lookup called exactly 2 times for that IOC.
- `test_retry_still_fails`: Mock adapter.lookup to return EnrichmentError both times. Verify final result is EnrichmentError. Verify adapter.lookup called exactly 2 times.
- `test_job_status_tracking`: Call enrich_all, then get_status(job_id). Verify status dict has keys: total, done, results, complete.
- `test_job_status_complete_flag`: After enrich_all finishes, verify get_status(job_id)["complete"] is True.
- `test_get_status_unknown_job`: get_status("nonexistent") returns None.
- `test_job_cleanup_lru`: Create 101 jobs (if LRU maxsize=100). Verify first job is evicted (get_status returns None).

Run: `python -m pytest tests/test_orchestrator.py -v`
All tests MUST FAIL.
  </action>
  <verify>
`python -m pytest tests/test_orchestrator.py -v` — all tests fail (NotImplementedError or assertion failures). Zero passes.
  </verify>
  <done>Test file covers parallel execution, error isolation, retry behavior, job tracking, and LRU cleanup. All fail against stubs.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN + REFACTOR — Implement EnrichmentOrchestrator to pass all tests</name>
  <files>
    app/enrichment/orchestrator.py
  </files>
  <action>
Implement the full `EnrichmentOrchestrator`:

```
class EnrichmentOrchestrator:
    def __init__(self, adapter, max_workers=4):
        self._adapter = adapter
        self._max_workers = max_workers  # Default 4 to respect VT free tier rate limit (Pitfall 7)
        self._jobs = OrderedDict()  # job_id -> status dict (LRU via OrderedDict)
        self._lock = Lock()
        self._max_jobs = 100  # LRU eviction threshold
```

**enrich_all(job_id, iocs):**
1. Filter enrichable IOCs: `[i for i in iocs if i.type in ENDPOINT_MAP]` (import ENDPOINT_MAP from VT adapter, or pass enrichable types as parameter)
2. Initialize job status: `{"total": len(enrichable), "done": 0, "results": [], "complete": False}`
3. Define inner `_do_lookup(ioc)` that:
   - Calls `self._adapter.lookup(ioc)`
   - If result is EnrichmentError, retry once: `self._adapter.lookup(ioc)` (per user decision: auto-retry once)
   - Returns final result
4. Submit all to `ThreadPoolExecutor(max_workers=self._max_workers)`:
   ```
   with ThreadPoolExecutor(max_workers=self._max_workers) as pool:
       futures = {pool.submit(_do_lookup, ioc): ioc for ioc in enrichable}
       for future in as_completed(futures):
           result = future.result()
           with self._lock:
               self._jobs[job_id]["results"].append(result)
               self._jobs[job_id]["done"] += 1
   ```
5. After all futures complete: set `self._jobs[job_id]["complete"] = True`
6. LRU eviction: if len(self._jobs) > self._max_jobs, pop oldest (first) entry

**get_status(job_id):**
- Acquire lock, return copy of job dict (or None if not found)
- Return a shallow copy to prevent external mutation

**Key design decisions:**
- `max_workers=4` default respects VT free tier 4 req/min (per research Pitfall 7)
- `OrderedDict` for simple LRU eviction (per research Open Question 2)
- Lock protects all reads/writes to `_jobs` dict
- `enrich_all` is designed to be called from a `threading.Thread` (Plan 03 wires this)

Run: `python -m pytest tests/test_orchestrator.py -v` — all pass.
Run: `python -m pytest -v --tb=short` — full suite passes, no regressions.

REFACTOR: Extract `_do_lookup` if needed. Ensure all methods <50 lines.
  </action>
  <verify>
`python -m pytest tests/test_orchestrator.py -v` — all pass.
`python -m pytest -v --tb=short` — full suite passes, no regressions.
`python -m pytest --cov=app/enrichment/orchestrator -v` — >90% coverage.
  </verify>
  <done>EnrichmentOrchestrator executes lookups in parallel via ThreadPoolExecutor, retries failures once, tracks job progress thread-safely, and evicts old jobs via LRU. All tests green, no regressions.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_orchestrator.py -v` — all orchestrator tests pass
2. `python -m pytest -v --tb=short` — full suite passes, no regressions
3. Timing test confirms parallel execution (wall time < sequential time)
4. Error isolation test confirms one failure doesn't crash others
5. Retry test confirms failed lookups are retried exactly once
</verification>

<success_criteria>
- ThreadPoolExecutor runs lookups in parallel (not sequential)
- Per-IOC errors do not block other IOC results (ENRC-06)
- Failed lookups are retried once before returning error
- Job status correctly tracks total, done, results, complete
- LRU eviction prevents memory leak on long-running sessions
- No regressions in Phase 1 or Plan 01 tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-enrichment/02-02-SUMMARY.md`
</output>
