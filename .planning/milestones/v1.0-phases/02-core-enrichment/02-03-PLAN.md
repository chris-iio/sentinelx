---
phase: 02-core-enrichment
plan: 03
type: execute
wave: 3
depends_on: [02-01, 02-02]
files_modified:
  - app/routes.py
  - app/__init__.py
  - app/config.py
  - app/templates/settings.html
  - app/templates/index.html
  - app/templates/base.html
  - tests/test_routes.py
  - tests/test_settings.py
autonomous: true
requirements: [UI-03, ENRC-05]

must_haves:
  truths:
    - "Settings page allows analyst to paste and save VT API key"
    - "When no API key configured, selecting online mode redirects to settings page"
    - "POST /analyze in online mode runs pipeline then launches enrichment in background thread"
    - "/analyze online mode returns results page immediately with job_id for polling"
    - "GET /enrichment/status/{job_id} returns JSON with total, done, complete, and serialized results"
    - "Each enrichment result in the JSON includes provider name, timestamp, and raw verdict (ENRC-05)"
    - "Navigation includes a Settings link"
  artifacts:
    - path: "app/templates/settings.html"
      provides: "API key settings page"
      contains: "form"
    - path: "app/routes.py"
      provides: "Settings routes, online-mode /analyze, polling endpoint"
      contains: "enrichment_status"
    - path: "tests/test_settings.py"
      provides: "Settings page and API key handling tests"
      min_lines: 30
  key_links:
    - from: "app/routes.py"
      to: "app/enrichment/orchestrator.py"
      via: "creates orchestrator, calls enrich_all in background thread"
      pattern: "orchestrator\\.enrich_all|Thread.*enrich"
    - from: "app/routes.py"
      to: "app/enrichment/config_store.py"
      via: "reads API key to check if configured"
      pattern: "config_store\\.get_vt_api_key|ConfigStore"
    - from: "app/routes.py"
      to: "app/enrichment/adapters/virustotal.py"
      via: "creates VTAdapter with API key from ConfigStore"
      pattern: "VTAdapter"
    - from: "app/templates/settings.html"
      to: "app/routes.py"
      via: "form POST to /settings"
      pattern: "url_for.*settings"
---

<objective>
Wire the enrichment system into Flask routes: settings page for API key management, online-mode /analyze that launches background enrichment, and a polling endpoint that returns enrichment progress as JSON with provider name, timestamp, and raw verdict.

Purpose: This plan connects the tested backend (VTAdapter, orchestrator from Plans 01-02) to the web layer. After this plan, the browser can submit in online mode, receive a job_id, and poll for incremental enrichment results.

Output: Working /settings page, online-mode /analyze with background enrichment, /enrichment/status endpoint returning JSON, integration tests.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Plan 01 and 02 outputs this plan depends on:
@app/enrichment/models.py (EnrichmentResult, EnrichmentError — for JSON serialization)
@app/enrichment/adapters/virustotal.py (VTAdapter — instantiated in route)
@app/enrichment/orchestrator.py (EnrichmentOrchestrator — created and called from route)
@app/enrichment/config_store.py (ConfigStore — reads API key)

# Existing routes and templates being modified:
@app/routes.py
@app/__init__.py
@app/templates/base.html
@app/templates/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Settings page and API key management routes</name>
  <files>
    app/routes.py
    app/templates/settings.html
    app/templates/base.html
    app/enrichment/config_store.py
    tests/test_settings.py
  </files>
  <action>
**app/templates/base.html** — Add Settings nav link to header:
- In the `header-inner` div, add a nav element with a link to `/settings` next to the tagline. Keep it minimal (plain anchor, styled as part of the header).

**app/templates/settings.html** — Create settings page extending base.html:
- Heading: "Settings"
- Section: "VirusTotal API Key"
- Form with: CSRF token ({{ csrf_token() }}), text input for API key (pre-filled if already saved, masked with `type="password"` + a show/hide toggle), save button
- If key just saved: show a success flash message
- Informational text: "Your API key is stored locally in ~/.sentinelx/config.ini. It is never transmitted except to the VirusTotal API." and "Get a free API key at https://www.virustotal.com/gui/join"
- Note: "API key is validated on first enrichment use, not on save" (per research Open Question 1 — accept-as-is)

**app/routes.py** — Add settings routes:
- `GET /settings` — reads current API key from ConfigStore (mask all but last 4 chars for display), renders settings.html
- `POST /settings` — validates key is non-empty string, saves via ConfigStore.set_vt_api_key(), redirects back to GET /settings with success flash
- Use `flash()` for success message, `get_flashed_messages()` in template

**tests/test_settings.py** — Write integration tests:
- `test_get_settings_page`: GET /settings returns 200, contains "VirusTotal API Key"
- `test_save_api_key`: POST /settings with api_key="test123", verify redirect to /settings, verify ConfigStore was called
- `test_save_empty_key_rejected`: POST /settings with empty key, verify error message
- `test_settings_page_masks_key`: Save a key, GET /settings, verify only last 4 chars visible
- Use `tmp_path` fixture or monkeypatch to isolate ConfigStore from real filesystem
  </action>
  <verify>
`python -m pytest tests/test_settings.py -v` — all pass.
`python -m pytest tests/test_routes.py -v` — existing route tests still pass (no regressions).
  </verify>
  <done>Settings page renders with API key form, saves/reads via ConfigStore, masks stored key, shows success feedback. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Online-mode /analyze with background enrichment and polling endpoint</name>
  <files>
    app/routes.py
    app/__init__.py
    app/templates/index.html
    app/config.py
    tests/test_routes.py
  </files>
  <action>
**app/routes.py** — Modify `/analyze` POST route for online mode:

When `mode == "online"`:
1. Check if VT API key is configured via ConfigStore. If not, redirect to `/settings` with flash message "Please configure your VirusTotal API key before using online mode" (per user decision: no API key -> redirect to settings).
2. Run pipeline: `iocs = run_pipeline(text)`, `grouped = group_by_type(iocs)` (same as offline).
3. Create a unique `job_id` using `uuid.uuid4().hex`.
4. Create VTAdapter with API key from ConfigStore and allowed_hosts from `current_app.config["ALLOWED_API_HOSTS"]`.
5. Create EnrichmentOrchestrator with the adapter.
6. Store the orchestrator reference (module-level dict or on app) so the polling endpoint can access it.
7. Launch enrichment in a daemon thread: `Thread(target=orchestrator.enrich_all, args=(job_id, iocs), daemon=True).start()` (per research Pitfall 4 — don't block Flask).
8. Render results.html with: `grouped`, `mode`, `total_count`, `no_results`, AND `job_id` (new parameter for polling JS).

When `mode == "offline"`: behavior unchanged from Phase 1.

**Add polling endpoint** — `GET /enrichment/status/<job_id>`:
- Look up orchestrator's job status via get_status(job_id)
- If job not found: return `{"error": "job not found"}`, 404
- Serialize results for JSON transport: each result becomes a dict with:
  - For EnrichmentResult: `{"type": "result", "ioc_value": r.ioc.value, "ioc_type": r.ioc.type.value, "provider": r.provider, "verdict": r.verdict, "detection_count": r.detection_count, "total_engines": r.total_engines, "scan_date": r.scan_date, "raw_stats": r.raw_stats}`
  - For EnrichmentError: `{"type": "error", "ioc_value": r.ioc.value, "ioc_type": r.ioc.type.value, "provider": r.provider, "error": r.error}`
- Return JSON: `{"total": status["total"], "done": status["done"], "complete": status["complete"], "results": [serialized...]}`
- CSRF exempt this endpoint (it's a GET, but ensure Flask-WTF doesn't interfere)

**app/templates/index.html** — Update online mode behavior:
- Add `data-settings-url="{{ url_for('main.settings_get') }}"` attribute to the mode select or form, so JS can redirect if needed.
- No other changes needed — the redirect-to-settings on no API key is handled server-side in the route.

**app/__init__.py** — No changes needed unless new blueprint or URL rule registration.

**app/config.py** — Verify `ALLOWED_API_HOSTS = ["www.virustotal.com"]` is set (done in Plan 01).

**tests/test_routes.py** — Add online-mode tests:
- `test_analyze_online_without_api_key_redirects_to_settings`: POST /analyze with mode=online and no API key configured, verify redirect to /settings
- `test_analyze_online_with_api_key_returns_job_id`: POST /analyze with mode=online and mock API key, verify results page contains a job_id data attribute
- `test_analyze_offline_unchanged`: POST /analyze with mode=offline, verify behavior identical to Phase 1 (no job_id, no enrichment)
- `test_enrichment_status_unknown_job`: GET /enrichment/status/nonexistent returns 404 JSON
- `test_enrichment_status_returns_json`: Mock an orchestrator with a known job, GET /enrichment/status/{job_id}, verify JSON structure has total, done, complete, results
- `test_enrichment_result_serialization`: Verify serialized result includes provider, verdict, scan_date (ENRC-05)

Use monkeypatch/mock to avoid real VT API calls in tests. Mock ConfigStore.get_vt_api_key to return a fake key.
  </action>
  <verify>
`python -m pytest tests/test_routes.py tests/test_settings.py -v` — all pass.
`python -m pytest -v --tb=short` — full suite passes, no regressions.
  </verify>
  <done>
- POST /analyze online mode: checks API key (redirects to settings if missing), runs pipeline, launches background enrichment, returns results page with job_id
- GET /enrichment/status/{job_id}: returns JSON with total, done, complete, and serialized results (provider name, timestamp, verdict per ENRC-05)
- Offline mode unchanged
- All integration tests pass
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_settings.py -v` — settings tests pass
2. `python -m pytest tests/test_routes.py -v` — route tests pass (existing + new)
3. `python -m pytest -v --tb=short` — full suite passes
4. `grep -r "Thread.*daemon" app/routes.py` — confirms background thread usage (Pitfall 4)
5. `grep -r "job_id" app/routes.py` — confirms job_id passed to template
6. `grep -r "enrichment_status\|enrichment/status" app/routes.py` — confirms polling endpoint exists
</verification>

<success_criteria>
- Settings page saves and retrieves VT API key via ConfigStore
- Online mode with no API key redirects to settings (user decision)
- Online mode launches enrichment in background thread (not blocking Flask)
- Polling endpoint returns JSON with provider, verdict, scan_date (ENRC-05)
- Offline mode is completely unchanged
- All tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-enrichment/02-03-SUMMARY.md`
</output>
