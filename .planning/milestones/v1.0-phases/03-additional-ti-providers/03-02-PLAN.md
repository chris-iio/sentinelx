---
phase: 03-additional-ti-providers
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - app/enrichment/adapters/threatfox.py
  - app/enrichment/models.py
  - app/config.py
  - tests/test_threatfox.py
autonomous: true
requirements: [ENRC-03]

must_haves:
  truths:
    - "ThreatFox adapter queries abuse.ch POST API for hashes (search_hash), domains, IPs, and URLs (search_ioc)"
    - "ThreatFox high-confidence hits (>=75) map to verdict=malicious"
    - "ThreatFox low-confidence hits (<75) map to verdict=suspicious"
    - "ThreatFox not-found results map to verdict=no_data"
    - "ThreatFox results include threat type, malware family, confidence level, and C2 indicator status"
    - "ThreatFox failure returns per-provider EnrichmentError without affecting other providers"
  artifacts:
    - path: "app/enrichment/adapters/threatfox.py"
      provides: "ThreatFox API adapter for hash, domain, IP, URL lookups"
      exports: ["TFAdapter"]
    - path: "tests/test_threatfox.py"
      provides: "ThreatFox adapter tests with mocked HTTP"
    - path: "app/enrichment/models.py"
      provides: "EnrichmentResult model (unchanged structure, 'suspicious' is a valid verdict string)"
  key_links:
    - from: "app/enrichment/adapters/threatfox.py"
      to: "https://threatfox-api.abuse.ch/api/v1/"
      via: "requests.post with search_ioc or search_hash query"
      pattern: "threatfox-api\\.abuse\\.ch"
    - from: "app/enrichment/adapters/threatfox.py"
      to: "app/enrichment/models.py"
      via: "returns EnrichmentResult with verdict malicious/suspicious/no_data"
      pattern: "EnrichmentResult"
---

<objective>
Build the ThreatFox adapter for hash, domain, IP, and URL IOC lookups with confidence-based verdict mapping.

Purpose: ThreatFox (abuse.ch) is a threat intelligence platform that tracks IOCs associated with malware and C2 infrastructure. Unlike MalwareBazaar (binary present/absent), ThreatFox provides a confidence_level (0-100) that should drive verdict mapping. Per user decision: high confidence (>=75) maps to malicious, low confidence (<75) maps to suspicious (new verdict level). This plan also introduces the 'suspicious' verdict as a valid value in the system.

Output: Working ThreatFox adapter, TDD-verified, with confidence-based verdict logic.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-enrichment/02-01-SUMMARY.md
@app/enrichment/adapters/virustotal.py
@app/enrichment/models.py
@app/pipeline/models.py
@app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED — Write failing tests for ThreatFox adapter</name>
  <files>tests/test_threatfox.py</files>
  <action>
Create `tests/test_threatfox.py` with mocked HTTP (unittest.mock.patch on requests.post):

**IOC type coverage tests:**
1. `test_lookup_sha256_found_high_confidence` — Mock POST to threatfox-api.abuse.ch with query=search_hash returning a match with confidence_level=90. Assert EnrichmentResult with provider="ThreatFox", verdict="malicious", raw_stats containing threat_type, malware_printable (malware family), confidence_level, and ioc_type_desc (C2 indicator status).
2. `test_lookup_domain_found_low_confidence` — Mock search_ioc returning a domain match with confidence_level=50. Assert verdict="suspicious".
3. `test_lookup_ip_found` — Mock search_ioc for an IPv4 IOC returning a match with confidence_level=80. Assert verdict="malicious".
4. `test_lookup_url_found` — Mock search_ioc for a URL IOC. Assert correct result.
5. `test_lookup_md5_found` — Mock search_hash for MD5. Assert correct result.

**Edge cases:**
6. `test_lookup_not_found` — Mock returning query_status="no_result". Assert EnrichmentResult with verdict="no_data", detection_count=0.
7. `test_lookup_unsupported_type_cve` — Pass a CVE IOC. Assert EnrichmentError with "Unsupported type".
8. `test_lookup_timeout` — Mock raising requests.exceptions.Timeout. Assert EnrichmentError with "Timeout".
9. `test_lookup_http_error` — Mock raising HTTPError. Assert EnrichmentError.
10. `test_ssrf_validation` — allowed_hosts missing threatfox-api.abuse.ch. Assert EnrichmentError with SSRF message.
11. `test_supported_types` — Assert TFAdapter.supported_types includes IOCType.MD5, SHA1, SHA256, DOMAIN, IPV4, IPV6, URL (all 7 enrichable types, not CVE).
12. `test_confidence_threshold_boundary_75` — confidence_level=75 exactly. Assert verdict="malicious" (>=75 threshold).
13. `test_confidence_threshold_boundary_74` — confidence_level=74. Assert verdict="suspicious" (<75 threshold).
14. `test_response_size_limit` — Mock oversized response. Assert EnrichmentError.
15. `test_multiple_results_uses_highest_confidence` — ThreatFox can return multiple IOC records for one query. Mock a response with 2 entries (confidence 40 and 90). Assert the adapter uses the highest-confidence entry.

Run: `python -m pytest tests/test_threatfox.py -x` — all tests MUST FAIL (RED).
  </action>
  <verify>
`python -m pytest tests/test_threatfox.py -x 2>&1 | tail -5` shows FAILED (ImportError since threatfox.py does not exist yet).
  </verify>
  <done>test_threatfox.py exists with all 15 test cases covering type support, confidence thresholds, error handling, and SSRF validation. All tests fail because TFAdapter does not exist yet.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN + REFACTOR — Implement ThreatFox adapter with confidence-based verdicts</name>
  <files>app/enrichment/adapters/threatfox.py, app/config.py</files>
  <action>
**app/enrichment/adapters/threatfox.py — New file:**

Create TFAdapter following the established adapter pattern:

```python
TF_BASE = "https://threatfox-api.abuse.ch/api/v1/"
TIMEOUT = (5, 30)
MAX_RESPONSE_BYTES = 1 * 1024 * 1024
CONFIDENCE_THRESHOLD = 75  # >=75 = malicious, <75 = suspicious (per user decision)

class TFAdapter:
    supported_types = {IOCType.IPV4, IOCType.IPV6, IOCType.DOMAIN, IOCType.URL,
                       IOCType.MD5, IOCType.SHA1, IOCType.SHA256}

    def __init__(self, allowed_hosts: list[str]) -> None:
        self._allowed_hosts = allowed_hosts

    def lookup(self, ioc: IOC) -> EnrichmentResult | EnrichmentError:
        # 1. Check supported type (CVE -> EnrichmentError)
        # 2. Validate endpoint against SSRF allowlist
        # 3. Determine query type:
        #    - Hash types (MD5, SHA1, SHA256): POST with {"query": "search_hash", "hash": ioc.value}
        #    - All others (IP, domain, URL): POST with {"query": "search_ioc", "search_term": ioc.value}
        # 4. HTTP safety: timeout=TIMEOUT, stream=True, allow_redirects=False
        # 5. Read response with byte cap
        # 6. Parse response
```

Response parsing:
- `query_status == "no_result"` -> EnrichmentResult(verdict="no_data", detection_count=0, total_engines=0, raw_stats={})
- `query_status == "ok"` with data array:
  - If multiple results, use the one with highest `confidence_level`
  - `confidence_level >= 75` -> verdict="malicious"
  - `confidence_level < 75` -> verdict="suspicious"
  - `raw_stats`: `{"threat_type": ..., "malware_printable": ..., "confidence_level": ..., "ioc_type_desc": ...}`
  - `detection_count`: 1 (found), `total_engines`: 1
  - `scan_date`: Use `first_seen` from the selected record
  - `provider`: "ThreatFox"

Per user decision on fields: threat type, malware family (malware_printable), confidence level, C2 indicator status (from ioc_type_desc or threat_type).

No API key needed — ThreatFox basic search queries are public (per user context).

Reuse `_validate_endpoint` and `_read_limited` patterns (copy into module, matching per-adapter isolation).

**app/config.py — Update ALLOWED_API_HOSTS:**

Add "threatfox-api.abuse.ch" to the list. After this plan, the list should be: `["www.virustotal.com", "mb-api.abuse.ch", "threatfox-api.abuse.ch"]`.

Note: app/config.py is also modified by Plan 01 (adds mb-api.abuse.ch). Since both plans are Wave 1, handle this carefully: if Plan 01 runs first, Plan 02 appends to the already-updated list. If Plan 02 runs first, add both new hosts. The executor should read the current state of the file and add what is missing. This is a small non-blocking overlap; the file is simple enough that both edits are additive (appending to a list literal).

**Do NOT modify app/enrichment/models.py** — the 'suspicious' verdict is simply a new string value in the verdict field. The EnrichmentResult model already uses `verdict: str` (not an enum), so "suspicious" is valid without schema changes. The CSS class `verdict-suspicious` will be added in Plan 03.

Run: `python -m pytest tests/ -x --tb=short` — ALL tests must pass (GREEN).
  </action>
  <verify>
`python -m pytest tests/ -x --tb=short` — 0 failures. `python -m pytest tests/test_threatfox.py -v` shows all 15 tests passing. `grep "threatfox-api.abuse.ch" app/config.py` confirms SSRF allowlist updated.
  </verify>
  <done>ThreatFox adapter queries abuse.ch for all 7 enrichable IOC types using search_hash (hashes) and search_ioc (domain/IP/URL). Confidence-based verdict mapping: >=75 is malicious, <75 is suspicious. Not-found returns no_data. All HTTP safety controls enforced. All tests pass, zero regressions.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -x --tb=short` — full suite passes
2. `python -m pytest tests/test_threatfox.py -v` — all 15 TF adapter tests pass
3. `grep "threatfox-api.abuse.ch" app/config.py` — SSRF allowlist includes ThreatFox
4. `grep "CONFIDENCE_THRESHOLD" app/enrichment/adapters/threatfox.py` — threshold is 75
5. `grep "suspicious" app/enrichment/adapters/threatfox.py` — suspicious verdict implemented
</verification>

<success_criteria>
- ThreatFox adapter independently testable with mocked HTTP (ENRC-03 partial)
- Confidence-based verdict mapping with 75 threshold (per user decision)
- 'suspicious' verdict level introduced for low-confidence ThreatFox hits
- Covers all 7 enrichable IOC types (hash via search_hash, others via search_ioc)
- No shared state between adapters
- All HTTP safety controls enforced
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/03-additional-ti-providers/03-02-SUMMARY.md`
</output>
