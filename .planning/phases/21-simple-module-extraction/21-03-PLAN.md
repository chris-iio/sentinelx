---
phase: 21-simple-module-extraction
plan: "03"
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - app/static/src/ts/modules/cards.ts
  - app/static/src/ts/modules/filter.ts
autonomous: true
requirements: [MOD-05, MOD-06]

must_haves:
  truths:
    - "cards.ts findCardForIoc returns the card element for a given IOC value using CSS.escape"
    - "cards.ts updateCardVerdict sets data-verdict attribute and updates verdict label text and class"
    - "cards.ts updateDashboardCounts counts cards by verdict and updates dashboard count elements"
    - "cards.ts sortCardsBySeverity debounces and reorders cards in the grid by verdict severity"
    - "filter.ts verdict buttons toggle active filter and show/hide cards"
    - "filter.ts type pills toggle active filter and show/hide cards"
    - "filter.ts search input filters cards by IOC value substring"
    - "filter.ts dashboard badge click syncs verdict filter"
    - "make typecheck passes with zero errors"
  artifacts:
    - path: "app/static/src/ts/modules/cards.ts"
      provides: "Card management: verdict updates, dashboard counts, severity sorting"
      exports: ["init", "findCardForIoc", "updateCardVerdict", "updateDashboardCounts", "sortCardsBySeverity"]
    - path: "app/static/src/ts/modules/filter.ts"
      provides: "Filter bar: verdict/type/search filtering, dashboard badge click"
      exports: ["init"]
  key_links:
    - from: "app/static/src/ts/modules/cards.ts"
      to: "app/static/src/ts/types/ioc.ts"
      via: "import { VERDICT_SEVERITY, VERDICT_LABELS } and import type { VerdictKey }"
      pattern: "import.*from.*types/ioc"
    - from: "app/static/src/ts/modules/cards.ts"
      to: "app/static/src/ts/utils/dom.ts"
      via: "import { attr }"
      pattern: "import.*attr.*from.*utils/dom"
    - from: "app/static/src/ts/modules/filter.ts"
      to: "app/static/src/ts/utils/dom.ts"
      via: "import { attr }"
      pattern: "import.*attr.*from.*utils/dom"
---

<objective>
Extract the card management and filter bar modules from main.js into typed TypeScript modules with proper exports for Phase 22's enrichment module to consume.

Purpose: cards.ts is the most interconnected simple module — it exports 4 functions (findCardForIoc, updateCardVerdict, updateDashboardCounts, sortCardsBySeverity) that Phase 22's enrichment.ts will import directly. filter.ts is the largest single function (~110 lines) with complex filtering state. Both exercise typed constants from Phase 20's ioc.ts.

Output: Two TypeScript modules with cards.ts exporting its public API for enrichment module consumption, all passing make typecheck.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/21-simple-module-extraction/21-RESEARCH.md
@.planning/phases/21-simple-module-extraction/21-01-SUMMARY.md

@app/static/main.js (source of truth — extract from lines 252-336 for cards, 677-788 for filter)
@app/static/src/ts/types/ioc.ts (Phase 20 types — VerdictKey, VERDICT_SEVERITY, VERDICT_LABELS)
@app/static/src/ts/utils/dom.ts (attr helper — created in Plan 01)
@tsconfig.json

<interfaces>
<!-- Phase 20 types — used by cards.ts -->

From app/static/src/ts/types/ioc.ts:
```typescript
export type VerdictKey = "error" | "no_data" | "clean" | "suspicious" | "malicious";
export const VERDICT_SEVERITY: readonly ["error", "no_data", "clean", "suspicious", "malicious"];
export const VERDICT_LABELS: Record<VerdictKey, string>;
```

<!-- Plan 01 utility — used by both modules -->

From app/static/src/ts/utils/dom.ts:
```typescript
export function attr(el: Element, name: string, fallback?: string): string;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create card management module</name>
  <files>app/static/src/ts/modules/cards.ts</files>
  <action>
Extract from main.js lines 252-336. Create `app/static/src/ts/modules/cards.ts` with these functions:

**Exports (5 functions):**
- `init()` — currently a no-op for Phase 21 (cards module has no DOMContentLoaded setup; its functions are called by the enrichment module). Export it for consistency with the module pattern — main.ts will call it in Phase 22. The init function body can be empty or contain a comment.
- `findCardForIoc(iocValue: string): HTMLElement | null` — finds card by data-ioc-value using CSS.escape
- `updateCardVerdict(iocValue: string, worstVerdict: VerdictKey): void` — updates card data-verdict, label text, label class
- `updateDashboardCounts(): void` — counts cards by verdict, updates dashboard count elements
- `sortCardsBySeverity(): void` — debounced sort wrapper

**Private functions (not exported):**
- `verdictSeverityIndex(verdict: VerdictKey): number` — returns index in VERDICT_SEVERITY array (replaces main.js `verdictSeverity()`)
- `doSortCards(): void` — actual DOM reorder logic

**TypeScript porting rules:**

1. **Import typed constants from Phase 20:**
   ```typescript
   import type { VerdictKey } from "../types/ioc";
   import { VERDICT_SEVERITY, VERDICT_LABELS } from "../types/ioc";
   import { attr } from "../utils/dom";
   ```
   Note: Use `import type` for VerdictKey (type-only) and regular `import` for VERDICT_SEVERITY, VERDICT_LABELS (runtime values).

2. **verdictSeverityIndex function:**
   - main.js `verdictSeverity(verdict)` does `VERDICT_SEVERITY.indexOf(verdict)` — returns -1 if not found
   - In TypeScript, `VERDICT_SEVERITY` is `readonly ["error", "no_data", "clean", "suspicious", "malicious"]`
   - `.indexOf()` on a readonly tuple requires the argument type to match. Since we're passing `VerdictKey` and the tuple contains all VerdictKey values, this works directly.
   - Keep the -1 fallback behavior — return idx directly.

3. **findCardForIoc:**
   - `document.querySelector('.ioc-card[data-ioc-value="' + CSS.escape(iocValue) + '"]')` — `CSS.escape()` is in lib.dom.d.ts, no import needed
   - Return type: `HTMLElement | null` — use `document.querySelector<HTMLElement>(...)`

4. **updateCardVerdict:**
   - Parameter `worstVerdict` typed as `VerdictKey` (not string) — callers must pass valid verdict
   - `card.setAttribute("data-verdict", worstVerdict)` — works, VerdictKey is a string subtype
   - Verdict label class manipulation: the original uses `label.className.split(" ")` with a for-loop to filter out `verdict-label--*` classes. Port this using `.filter()` for cleanliness:
     ```typescript
     const classes = label.className.split(" ").filter(c => !c.startsWith("verdict-label--"));
     classes.push("verdict-label--" + worstVerdict);
     label.className = classes.join(" ");
     ```
   - `VERDICT_LABELS[worstVerdict]` — typed correctly since VerdictKey is the key type of VERDICT_LABELS Record. No `|| worstVerdict.toUpperCase()` fallback needed at the type level, but keep it for runtime safety (matches original behavior).

5. **updateDashboardCounts:**
   - Type the counts object: `const counts: Record<string, number> = { malicious: 0, suspicious: 0, clean: 0, no_data: 0 };`
   - Replace `for (var i = 0; i < cards.length; i++)` with `cards.forEach(card => ...)` to avoid noUncheckedIndexedAccess
   - `attr(card, "data-verdict")` instead of `card.getAttribute("data-verdict") || ""`
   - `Object.prototype.hasOwnProperty.call(counts, v)` — same pattern works in TypeScript
   - Under noUncheckedIndexedAccess, `counts[v]` returns `number | undefined` — use `(counts[v] ?? 0) + 1` and reassign
   - Dashboard query: use `document.querySelector<HTMLElement>(...)` with null check

6. **sortCardsBySeverity (debounced) + doSortCards:**
   - Module-level timer: `let sortTimer: ReturnType<typeof setTimeout> | null = null;`
   - `sortCardsBySeverity()`: `if (sortTimer !== null) clearTimeout(sortTimer); sortTimer = setTimeout(doSortCards, 100);`
   - `doSortCards()`:
     - `Array.from(grid.querySelectorAll<HTMLElement>(".ioc-card"))` instead of `Array.prototype.slice.call(...)`
     - Sort comparison: `attr(a, "data-verdict", "no_data")` — but needs to be cast to VerdictKey for `verdictSeverityIndex`. Use `attr(a, "data-verdict", "no_data") as VerdictKey` — this is acceptable since the value comes from DOM attributes that we set.
     - `cards.forEach(card => grid.appendChild(card))` instead of indexed for-loop for the reorder step

7. **No non-null assertions.** Every querySelector/getElementById result guarded with `if (!el) return`.

Run `make typecheck` after writing the file.
  </action>
  <verify>
    <automated>cd /home/chris/projects/sentinelx && make typecheck 2>&1 | tail -5</automated>
  </verify>
  <done>cards.ts exports init, findCardForIoc, updateCardVerdict, updateDashboardCounts, sortCardsBySeverity; uses VERDICT_SEVERITY/VERDICT_LABELS from types; module-level sortTimer with ReturnType<typeof setTimeout>; make typecheck clean</done>
</task>

<task type="auto">
  <name>Task 2: Create filter bar module</name>
  <files>app/static/src/ts/modules/filter.ts</files>
  <action>
Extract from main.js lines 677-788. Create `app/static/src/ts/modules/filter.ts`:

**Exports:** `init` (single exported function)

**All other functions are nested inside init (closure pattern preserved from original):**
- `applyFilter()` — shows/hides cards based on filterState, updates active button styles

**TypeScript porting rules:**

1. **Filter state interface:**
   Define inside the module (not exported — internal to filter.ts):
   ```typescript
   interface FilterState {
     verdict: string;
     type: string;
     search: string;
   }
   ```
   Initialize: `const filterState: FilterState = { verdict: "all", type: "all", search: "" };`

2. **Replace IIFE closures with forEach:**
   main.js lines 734-747 use the IIFE-in-for-loop pattern:
   ```javascript
   for (var i = 0; i < verdictBtns.length; i++) {
     (function (btn) { btn.addEventListener(...) })(verdictBtns[i]);
   }
   ```
   In TypeScript with `const` (block-scoped), this simplifies to:
   ```typescript
   verdictBtns.forEach(btn => {
     btn.addEventListener("click", () => { ... });
   });
   ```
   Apply this to ALL three IIFE loops: verdict buttons (lines 734-747), type pills (lines 750-763), and dashboard badges (lines 778-786).

3. **querySelectorAll typing:**
   - `filterRoot.querySelectorAll(".ioc-card")` → `filterRoot.querySelectorAll<HTMLElement>(".ioc-card")`
   - `filterRoot.querySelectorAll("[data-filter-verdict]")` → `filterRoot.querySelectorAll<HTMLElement>("[data-filter-verdict]")`
   - `filterRoot.querySelectorAll("[data-filter-type]")` → `filterRoot.querySelectorAll<HTMLElement>("[data-filter-type]")`
   - `dashboard.querySelectorAll(".verdict-kpi-card[data-verdict]")` → `dashboard.querySelectorAll<HTMLElement>(...)`

4. **getAttribute → attr() helper:**
   ALL getAttribute calls in filter.ts must use `attr()` from `../utils/dom`:
   - `card.getAttribute("data-verdict")` → `attr(card, "data-verdict")`
   - `card.getAttribute("data-ioc-type")` → `attr(card, "data-ioc-type")`
   - `card.getAttribute("data-ioc-value")` → `attr(card, "data-ioc-value")`
   - `btn.getAttribute("data-filter-verdict")` → `attr(btn, "data-filter-verdict")`
   - `pill.getAttribute("data-filter-type")` → `attr(pill, "data-filter-type")`
   - `badge.getAttribute("data-verdict")` → `attr(badge, "data-verdict")`

   **Key behavior note:** The original uses `|| ""` after getAttribute to handle null. The `attr()` helper returns `""` by default for missing attributes, so the behavior is identical.

5. **applyFilter card iteration:**
   Replace `for (var i = 0; i < cards.length; i++)` with `cards.forEach(card => ...)`.
   The original pattern:
   ```javascript
   var cardVerdict = (card.getAttribute("data-verdict") || "").toLowerCase();
   ```
   Becomes:
   ```typescript
   const cardVerdict = attr(card, "data-verdict").toLowerCase();
   ```
   Same for cardType and cardValue.

6. **Style manipulation:**
   `card.style.display = (verdictMatch && typeMatch && searchMatch) ? "" : "none";`
   This requires `card` to be `HTMLElement` (not `Element`) — ensure querySelectorAll generic is used.

7. **Search input typing:**
   `document.getElementById("filter-search-input")` → cast to `HTMLInputElement | null` for `.value` access:
   ```typescript
   const searchInput = document.getElementById("filter-search-input") as HTMLInputElement | null;
   if (searchInput) {
     searchInput.addEventListener("input", () => {
       filterState.search = searchInput.value;
       applyFilter();
     });
   }
   ```

8. **Verdict/type button active state:**
   Both loops in applyFilter() that update active classes (lines 708-729) use the same pattern — replace indexed for-loops with forEach, use `attr()` for getAttribute, use `classList.add/remove` as in original.

9. **No non-null assertions.** Every DOM query guarded with `if (!el) return`.

Do NOT change any behavior. The filter logic (verdict toggle, type toggle, search substring, dashboard badge sync) must be identical.

Run `make typecheck` after writing the file.
  </action>
  <verify>
    <automated>cd /home/chris/projects/sentinelx && make typecheck 2>&1 | tail -5</automated>
  </verify>
  <done>filter.ts exports init(); FilterState interface typed; IIFE closures replaced with forEach; all getAttribute calls use attr() helper; make typecheck clean</done>
</task>

</tasks>

<verification>
1. `make typecheck` exits 0 — all Phase 21 files (utils/dom, 6 modules) pass strict TypeScript checking
2. `grep 'export function' app/static/src/ts/modules/cards.ts` shows init, findCardForIoc, updateCardVerdict, updateDashboardCounts, sortCardsBySeverity
3. `grep 'export function' app/static/src/ts/modules/filter.ts` shows only init
4. `grep -rn 'ReturnType<typeof setTimeout>' app/static/src/ts/modules/cards.ts` shows sortTimer declaration
5. `grep -rn 'NodeJS' app/static/src/ts/modules/` returns no results
6. `grep -rn 'getAttribute' app/static/src/ts/modules/cards.ts app/static/src/ts/modules/filter.ts` returns no results (all replaced by attr())
7. No non-null assertions in any module file
</verification>

<success_criteria>
- cards.ts: 5 exported functions; uses VERDICT_SEVERITY and VERDICT_LABELS from types/ioc; module-level sortTimer with ReturnType<typeof setTimeout>; CSS.escape for card lookup
- filter.ts: init() with FilterState interface; 3 IIFE loops replaced with forEach; all getAttribute calls use attr() helper; search input typed as HTMLInputElement
- Zero TypeScript errors from make typecheck across entire src/ts directory
- No non-null assertions, no NodeJS.Timeout, no raw getAttribute calls
- cards.ts public API ready for Phase 22 enrichment module to import
</success_criteria>

<output>
After completion, create `.planning/phases/21-simple-module-extraction/21-03-SUMMARY.md`
</output>
