---
phase: 20-type-definitions-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/static/src/ts/types/ioc.ts
  - app/static/src/ts/types/api.ts
autonomous: true
requirements: [TYPE-01, TYPE-02, TYPE-03, TYPE-04]

must_haves:
  truths:
    - "`make typecheck` exits 0 with zero errors on all TypeScript files including the new type definitions"
    - "Using an invalid verdict key like `\"invalid\"` to index `VERDICT_LABELS` produces a TypeScript compile error"
    - "A field name typo in a consuming module that references `EnrichmentResultItem` causes a type error at compile time"
    - "Using a Node.js global like `process` in a TypeScript file produces a type error (types:[] enforcement)"
  artifacts:
    - path: "app/static/src/ts/types/ioc.ts"
      provides: "VerdictKey and IocType union types, VERDICT_SEVERITY, VERDICT_LABELS, IOC_PROVIDER_COUNTS typed constants"
      exports: ["VerdictKey", "IocType", "VERDICT_SEVERITY", "VERDICT_LABELS", "IOC_PROVIDER_COUNTS"]
    - path: "app/static/src/ts/types/api.ts"
      provides: "EnrichmentResultItem, EnrichmentErrorItem, EnrichmentItem, EnrichmentStatus interfaces"
      exports: ["EnrichmentResultItem", "EnrichmentErrorItem", "EnrichmentItem", "EnrichmentStatus"]
  key_links:
    - from: "app/static/src/ts/types/api.ts"
      to: "app/static/src/ts/types/ioc.ts"
      via: "import type { VerdictKey } from './ioc'"
      pattern: "import type.*VerdictKey.*from.*ioc"
    - from: "tsconfig.json"
      to: "app/static/src/ts/**/*.ts"
      via: "include glob covers types/ subdirectory"
      pattern: "app/static/src/ts/\\*\\*/\\*.ts"
---

<objective>
Create the shared TypeScript type layer — domain types (VerdictKey, IocType, typed constants) and API response interfaces (EnrichmentStatus, discriminated union items) — that all downstream modules will import from.

Purpose: Centralize the domain model before module conversion begins. Types are erased at compile time (zero runtime cost) but provide IDE feedback and catch type errors during `tsc --noEmit`. Without this foundation, Phases 21-22 would each need to define their own ad-hoc types.

Output: Two type files in `app/static/src/ts/types/` — `ioc.ts` (domain types + constants) and `api.ts` (API response interfaces). `make typecheck` passes on all files.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-type-definitions-foundation/20-RESEARCH.md

Source files for exact values:
@app/static/main.js (lines 228-250: VERDICT_SEVERITY, VERDICT_LABELS, IOC_PROVIDER_COUNTS)
@app/routes.py (_serialize_result function: JSON field names and types)
@app/enrichment/models.py (EnrichmentResult and EnrichmentError dataclasses)
@tsconfig.json (existing config — verify, do not modify)

<interfaces>
<!-- Existing tsconfig.json — already correct, no changes needed -->
```json
{
  "compilerOptions": {
    "target": "es2022",
    "lib": ["es2022", "dom", "dom.iterable"],
    "module": "es2022",
    "moduleResolution": "Bundler",
    "strict": true,
    "noEmit": true,
    "isolatedModules": true,
    "noUncheckedIndexedAccess": true,
    "types": [],
    "skipLibCheck": false
  },
  "include": ["app/static/src/ts/**/*.ts"]
}
```

<!-- Existing main.ts placeholder — unchanged in Phase 20 -->
```typescript
// app/static/src/ts/main.ts
// Phase 19 placeholder — full implementation in Phases 21-22.
export {};
```

<!-- Flask _serialize_result output — the exact JSON shape api.ts must match -->
```python
# EnrichmentResult branch:
{"type": "result", "ioc_value": str, "ioc_type": str, "provider": str,
 "verdict": str, "detection_count": int, "total_engines": int,
 "scan_date": str | None, "raw_stats": dict}

# EnrichmentError branch:
{"type": "error", "ioc_value": str, "ioc_type": str, "provider": str,
 "error": str}

# Top-level enrichment_status response:
{"total": int, "done": int, "complete": bool, "results": list[dict]}
```

<!-- main.js constants — the exact values ioc.ts must define -->
```javascript
var VERDICT_SEVERITY = ["error", "no_data", "clean", "suspicious", "malicious"];
var VERDICT_LABELS = {
    "malicious":  "MALICIOUS",
    "suspicious": "SUSPICIOUS",
    "clean":      "CLEAN",
    "no_data":    "NO DATA",
    "error":      "ERROR"
};
var IOC_PROVIDER_COUNTS = {
    "ipv4": 2, "ipv6": 2, "domain": 2, "url": 2,
    "md5": 3, "sha1": 3, "sha256": 3
};
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create domain types and API response interfaces</name>
  <files>app/static/src/ts/types/ioc.ts, app/static/src/ts/types/api.ts</files>
  <action>
Create directory `app/static/src/ts/types/`.

**File 1: `app/static/src/ts/types/ioc.ts`**

Define the following exports exactly:

1. `VerdictKey` — union type: `"error" | "no_data" | "clean" | "suspicious" | "malicious"`. These are the five verdict keys returned by the Flask enrichment API.

2. `IocType` — union type: `"ipv4" | "ipv6" | "domain" | "url" | "md5" | "sha1" | "sha256"`. Only the 7 enrichable types — NOT `"cve"` (CVEs are extracted but never enriched, and `IOC_PROVIDER_COUNTS` has no `cve` entry).

3. `VERDICT_SEVERITY` — `as const` array: `["error", "no_data", "clean", "suspicious", "malicious"]`. Index 0 = least severe. Type: `readonly ["error", "no_data", "clean", "suspicious", "malicious"]` (tuple preserved by `as const`). Source: main.js line 228.

4. `VERDICT_LABELS` — typed as `Record<VerdictKey, string>` with `as const`. Contains the five key-value pairs: malicious→"MALICIOUS", suspicious→"SUSPICIOUS", clean→"CLEAN", no_data→"NO DATA", error→"ERROR". Source: main.js lines 231-237.

5. `IOC_PROVIDER_COUNTS` — typed as `Record<IocType, number>` with `as const`. Contains 7 entries: ipv4:2, ipv6:2, domain:2, url:2, md5:3, sha1:3, sha256:3. Source: main.js lines 242-250.

Add JSDoc comments on each export explaining its purpose and source line from main.js.

**File 2: `app/static/src/ts/types/api.ts`**

Define the following exports exactly:

1. `import type { VerdictKey } from "./ioc"` — type-only import (mandatory under `isolatedModules` since `VerdictKey` is used only as a type).

2. `EnrichmentResultItem` — interface matching the `"type": "result"` branch of `_serialize_result` in routes.py:
   - `type: "result"` (literal string, discriminant)
   - `ioc_value: string`
   - `ioc_type: string`
   - `provider: string`
   - `verdict: VerdictKey` (NOT `string` — use the typed union)
   - `detection_count: number`
   - `total_engines: number`
   - `scan_date: string | null` (always present, possibly null — NOT optional `?:`)
   - `raw_stats: Record<string, unknown>` (NOT `object`, NOT `any`)

3. `EnrichmentErrorItem` — interface matching the `"type": "error"` branch:
   - `type: "error"` (literal string, discriminant)
   - `ioc_value: string`
   - `ioc_type: string`
   - `provider: string`
   - `error: string`

4. `EnrichmentItem` — discriminated union: `EnrichmentResultItem | EnrichmentErrorItem`

5. `EnrichmentStatus` — interface matching the top-level `enrichment_status` response:
   - `total: number`
   - `done: number`
   - `complete: boolean`
   - `results: EnrichmentItem[]`

Add JSDoc comments referencing the Flask source (routes.py `_serialize_result`, `enrichment_status`) and the Python dataclasses (enrichment/models.py).

**Critical constraints:**
- Every file MUST have at least one `export` (required by `isolatedModules: true`)
- Use `import type` (not `import`) when importing types only
- Use `as const` on constant values to preserve literal types
- Use `Record<VerdictKey, string>` and `Record<IocType, number>` (not `Record<string, ...>`) so that `noUncheckedIndexedAccess` works correctly with typed keys
- No `any` types anywhere
- No non-null assertions (`!`) anywhere
- No runtime code — these are pure type/constant definitions
  </action>
  <verify>
    <automated>cd /home/chris/projects/sentinelx && make typecheck 2>&1; echo "EXIT: $?"</automated>
  </verify>
  <done>Both type files exist with all specified exports. `make typecheck` exits 0 with no errors. `ioc.ts` exports VerdictKey, IocType, VERDICT_SEVERITY, VERDICT_LABELS, IOC_PROVIDER_COUNTS. `api.ts` exports EnrichmentResultItem, EnrichmentErrorItem, EnrichmentItem, EnrichmentStatus with correct discriminated union pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Verify tsconfig enforcement and type safety</name>
  <files>app/static/src/ts/types/ioc.ts, app/static/src/ts/types/api.ts</files>
  <action>
Verify four specific type-safety behaviors by creating temporary test scripts and confirming they produce the expected results. This task does NOT modify the type files — it only validates them.

**Verification 1 — TYPE-01: tsconfig strict options**
Read `tsconfig.json` and confirm these four options are present and correctly valued:
- `strict: true`
- `isolatedModules: true`
- `noUncheckedIndexedAccess: true`
- `"types": []`

Then create a temporary file `app/static/src/ts/_verify.ts` that uses `process.env` (Node.js global). Run `make typecheck`. Verify it FAILS with an error referencing `process`. Delete the temporary file.

**Verification 2 — TYPE-02: Invalid verdict key detection**
Create a temporary file `app/static/src/ts/_verify.ts`:
```typescript
import { VERDICT_LABELS } from "./types/ioc";
const bad = VERDICT_LABELS["invalid" as any]; // this should compile
// But proper usage:
// const x: import("./types/ioc").VerdictKey = "invalid"; // this would fail
```

Instead, create:
```typescript
import type { VerdictKey } from "./types/ioc";
const v: VerdictKey = "invalid";
```

Run `make typecheck`. Verify it FAILS with a type error about `"invalid"` not being assignable to `VerdictKey`. Delete the temporary file.

**Verification 3 — TYPE-03: Discriminated union narrowing**
Create a temporary file `app/static/src/ts/_verify.ts`:
```typescript
import type { EnrichmentItem } from "./types/api";

function test(item: EnrichmentItem): void {
    if (item.type === "result") {
        const v = item.verdict; // should compile — EnrichmentResultItem has verdict
    } else {
        const e = item.error; // should compile — EnrichmentErrorItem has error
    }
}

export {};
```

Run `make typecheck`. Verify it PASSES (exit 0). Delete the temporary file.

**Verification 4 — TYPE-04: DOM null-checking pattern confirmed**
TYPE-04 specifies "All DOM element access uses proper null-checking (no non-null assertions)". The type definition files in Phase 20 have no DOM access at all — this is correct because TYPE-04's enforcement scope is Phases 21-22 (module conversion). Verify that neither `ioc.ts` nor `api.ts` contain any `!` non-null assertions or DOM API calls (`getElementById`, `querySelector`). This is a grep check, not a compile check.

After all four verifications pass, ensure no temporary files remain. Run `make typecheck` one final time to confirm the clean state.
  </action>
  <verify>
    <automated>cd /home/chris/projects/sentinelx && make typecheck 2>&1 && echo "PASS" || echo "FAIL"; test ! -f app/static/src/ts/_verify.ts && echo "CLEANUP OK" || echo "CLEANUP FAILED"</automated>
  </verify>
  <done>All four verification checks pass: (1) tsconfig.json has strict/isolatedModules/noUncheckedIndexedAccess/types:[] — Node.js globals are rejected; (2) Invalid verdict key assignment produces a compile error; (3) Discriminated union narrowing works correctly on EnrichmentItem; (4) Type files contain no non-null assertions or DOM access. No temporary files remain. `make typecheck` exits 0 in final clean state.</done>
</task>

</tasks>

<verification>
1. `make typecheck` exits 0 with zero errors — all type files compile cleanly under strict mode
2. Both type files exist at the specified paths under `app/static/src/ts/types/`
3. `tsconfig.json` include glob `app/static/src/ts/**/*.ts` covers the new `types/` subdirectory (no tsconfig change needed)
4. Running `make js` still produces `app/static/dist/main.js` (type files are type-only — they do not affect the IIFE bundle because nothing imports them yet from main.ts)
5. No `any` type annotations in either type file
6. No non-null assertions (`!`) in either type file
</verification>

<success_criteria>
- `app/static/src/ts/types/ioc.ts` defines VerdictKey, IocType, VERDICT_SEVERITY, VERDICT_LABELS, IOC_PROVIDER_COUNTS with correct types and values matching main.js lines 228-250
- `app/static/src/ts/types/api.ts` defines EnrichmentResultItem, EnrichmentErrorItem, EnrichmentItem (discriminated union), EnrichmentStatus matching the Flask /enrichment/status/{job_id} response shape
- `make typecheck` exits 0 on the type files
- tsconfig.json remains unchanged (already correct from Phase 19)
- Invalid verdict key usage produces a compile error (verified)
- Node.js global usage produces a compile error (verified)
- Discriminated union narrowing works correctly (verified)
</success_criteria>

<output>
After completion, create `.planning/phases/20-type-definitions-foundation/20-01-SUMMARY.md`
</output>
