"""MalwareBazaar API adapter.

Implements IOC hash enrichment against the MalwareBazaar API (abuse.ch) with
full HTTP safety controls matching the VTAdapter pattern:
  - SEC-04: timeout=(5, 30) on all requests
  - SEC-05: stream=True + byte counting, 1 MB response cap
  - SEC-06: allow_redirects=False on all requests
  - SEC-07/SEC-16: ALLOWED_API_HOSTS allowlist enforced before every network call

MalwareBazaar semantics:
  - Finding a hash in MalwareBazaar means it IS a malware sample (verdict=malicious)
  - Not finding it means no data (verdict=no_data) — not that it is clean
  - hash_not_found is a meaningful absence of data, not a failure
  - No API key required for public hash queries (abuse.ch policy)

Thread safety: a fresh requests.post call is used per lookup() call (no shared Session).
"""
from __future__ import annotations

import json
from urllib.parse import urlparse

import requests
import requests.exceptions

from app.enrichment.models import EnrichmentError, EnrichmentResult
from app.pipeline.models import IOC, IOCType

MB_BASE = "https://mb-api.abuse.ch/api/v1/"
TIMEOUT = (5, 30)  # (connect, read) — SEC-04
MAX_RESPONSE_BYTES = 1 * 1024 * 1024  # 1 MB cap — SEC-05


def _validate_endpoint(url: str, allowed_hosts: list[str]) -> None:
    """Raise ValueError if endpoint hostname is not on the SSRF allowlist.

    Enforces SEC-16: no outbound calls to hosts outside ALLOWED_API_HOSTS.
    Called before every network request.

    Args:
        url:           The full URL to be requested.
        allowed_hosts: SSRF allowlist of permitted hostnames.

    Raises:
        ValueError: If the URL hostname is not in the allowlist.
    """
    parsed = urlparse(url)
    if parsed.hostname not in allowed_hosts:
        raise ValueError(
            f"Endpoint hostname {parsed.hostname!r} not in allowed_hosts "
            f"(SSRF allowlist SEC-16). Allowed: {allowed_hosts!r}"
        )


def _read_limited(resp: requests.Response) -> dict:
    """Read streaming response with byte cap (SEC-05).

    Reads response body in 8 KB chunks. Raises ValueError if total
    exceeds MAX_RESPONSE_BYTES before completing. Returns parsed JSON.

    Args:
        resp: An open streaming requests.Response.

    Raises:
        ValueError: If response body exceeds MAX_RESPONSE_BYTES.
        json.JSONDecodeError: If body is not valid JSON.
    """
    chunks: list[bytes] = []
    total = 0
    for chunk in resp.iter_content(chunk_size=8192):
        total += len(chunk)
        if total > MAX_RESPONSE_BYTES:
            raise ValueError(
                f"Response exceeded size limit of {MAX_RESPONSE_BYTES} bytes (SEC-05)"
            )
        chunks.append(chunk)
    return json.loads(b"".join(chunks))


class MBAdapter:
    """Adapter for the MalwareBazaar API (abuse.ch).

    Supports hash IOC lookups (MD5, SHA1, SHA256) using the abuse.ch POST API.
    Finding a hash in MalwareBazaar indicates a confirmed malware sample
    (verdict=malicious). Not finding a hash returns verdict=no_data.

    No API key required — MalwareBazaar hash queries are public.

    Thread safety: uses a standalone requests.post call per lookup() invocation.
    No shared session state between calls.

    Args:
        allowed_hosts: SSRF allowlist — only these hostnames may be contacted.
    """

    # Only hash types are supported — MalwareBazaar has no IP/domain/URL endpoint
    supported_types = {IOCType.MD5, IOCType.SHA1, IOCType.SHA256}

    def __init__(self, allowed_hosts: list[str]) -> None:
        self._allowed_hosts = allowed_hosts

    def lookup(self, ioc: IOC) -> EnrichmentResult | EnrichmentError:
        """Enrich a single hash IOC using the MalwareBazaar API.

        Returns EnrichmentError immediately for non-hash types.
        Validates the MB endpoint against the SSRF allowlist before any
        network call. Makes a POST request with full safety controls and
        parses the response.

        Response semantics:
          - query_status == "ok"             -> found (verdict=malicious)
          - query_status == "hash_not_found" -> not found (verdict=no_data)
          - HTTP error / timeout / exception  -> EnrichmentError

        Args:
            ioc: The IOC to look up. Must be MD5, SHA1, or SHA256.

        Returns:
            EnrichmentResult with verdict "malicious" (found) or "no_data" (not found).
            EnrichmentError on unsupported type, SSRF block, or network failure.
        """
        if ioc.type not in self.supported_types:
            return EnrichmentError(
                ioc=ioc, provider="MalwareBazaar", error="Unsupported type"
            )

        try:
            _validate_endpoint(MB_BASE, self._allowed_hosts)
        except ValueError as exc:
            return EnrichmentError(ioc=ioc, provider="MalwareBazaar", error=str(exc))

        try:
            resp = requests.post(
                MB_BASE,
                data={"query": "get_info", "hash": ioc.value},
                timeout=TIMEOUT,           # SEC-04
                allow_redirects=False,     # SEC-06
                stream=True,               # SEC-05 setup
            )
            resp.raise_for_status()
            body = _read_limited(resp)     # SEC-05: byte cap enforced
            return self._parse_response(ioc, body)
        except requests.exceptions.Timeout:
            return EnrichmentError(ioc=ioc, provider="MalwareBazaar", error="Timeout")
        except requests.exceptions.HTTPError as exc:
            code = exc.response.status_code if exc.response is not None else "unknown"
            return EnrichmentError(
                ioc=ioc, provider="MalwareBazaar", error=f"HTTP {code}"
            )
        except Exception as exc:
            return EnrichmentError(ioc=ioc, provider="MalwareBazaar", error=str(exc))

    def _parse_response(self, ioc: IOC, body: dict) -> EnrichmentResult:
        """Parse a MalwareBazaar API response into an EnrichmentResult.

        MalwareBazaar uses query_status to indicate result presence.
        If status is "ok", the hash was found (confirmed malware sample).
        If status is "hash_not_found", no record exists.

        For found hashes, extracts: file_type, signature (malware family),
        tags, first_seen, and last_seen from the first data entry.

        Args:
            ioc:  The IOC that was queried.
            body: Parsed JSON from MalwareBazaar API response.

        Returns:
            EnrichmentResult with verdict "malicious" (found) or "no_data" (not found).
        """
        query_status = body.get("query_status", "")

        if query_status == "hash_not_found":
            return EnrichmentResult(
                ioc=ioc,
                provider="MalwareBazaar",
                verdict="no_data",
                detection_count=0,
                total_engines=0,
                scan_date=None,
                raw_stats={},
            )

        # query_status == "ok" — hash found in MalwareBazaar = confirmed malware sample
        data_list = body.get("data", [])
        sample = data_list[0] if data_list else {}

        raw_stats = {
            "file_type": sample.get("file_type"),
            "signature": sample.get("signature"),  # malware family
            "tags": sample.get("tags", []),
            "first_seen": sample.get("first_seen"),
            "last_seen": sample.get("last_seen"),
        }

        return EnrichmentResult(
            ioc=ioc,
            provider="MalwareBazaar",
            verdict="malicious",
            detection_count=1,   # Binary: present in MalwareBazaar = malware
            total_engines=1,     # MalwareBazaar is single-source (present/not)
            scan_date=sample.get("first_seen"),
            raw_stats=raw_stats,
        )
