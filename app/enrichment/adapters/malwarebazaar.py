"""MalwareBazaar API adapter.

Implements IOC hash enrichment against the MalwareBazaar API (abuse.ch) with
full HTTP safety controls matching the VTAdapter pattern:
  - SEC-04: timeout=(5, 30) on all requests
  - SEC-05: stream=True + byte counting, 1 MB response cap
  - SEC-06: allow_redirects=False on all requests
  - SEC-07/SEC-16: ALLOWED_API_HOSTS allowlist enforced before every network call

MalwareBazaar semantics:
  - Finding a hash in MalwareBazaar means it IS a malware sample (verdict=malicious)
  - Not finding it means no data (verdict=no_data) — not that it is clean
  - hash_not_found is a meaningful absence of data, not a failure
  - No API key required for public hash queries (abuse.ch policy)

Thread safety: a fresh requests.post call is used per lookup() call (no shared Session).
"""
from __future__ import annotations

import logging

import requests
import requests.exceptions

from app.enrichment.http_safety import TIMEOUT, read_limited, validate_endpoint
from app.enrichment.models import EnrichmentError, EnrichmentResult
from app.pipeline.models import IOC, IOCType

logger = logging.getLogger(__name__)

MB_BASE = "https://mb-api.abuse.ch/api/v1/"


class MBAdapter:
    """Adapter for the MalwareBazaar API (abuse.ch).

    Supports hash IOC lookups (MD5, SHA1, SHA256) using the abuse.ch POST API.
    Finding a hash in MalwareBazaar indicates a confirmed malware sample
    (verdict=malicious). Not finding a hash returns verdict=no_data.

    No API key required — MalwareBazaar hash queries are public.

    Thread safety: uses a standalone requests.post call per lookup() invocation.
    No shared session state between calls.

    Args:
        allowed_hosts: SSRF allowlist — only these hostnames may be contacted.
    """

    # Only hash types are supported — MalwareBazaar has no IP/domain/URL endpoint
    supported_types = {IOCType.MD5, IOCType.SHA1, IOCType.SHA256}

    def __init__(self, allowed_hosts: list[str]) -> None:
        self._allowed_hosts = allowed_hosts

    def lookup(self, ioc: IOC) -> EnrichmentResult | EnrichmentError:
        """Enrich a single hash IOC using the MalwareBazaar API.

        Returns EnrichmentError immediately for non-hash types.
        Validates the MB endpoint against the SSRF allowlist before any
        network call. Makes a POST request with full safety controls and
        parses the response.

        Response semantics:
          - query_status == "ok"             -> found (verdict=malicious)
          - query_status == "hash_not_found" -> not found (verdict=no_data)
          - HTTP error / timeout / exception  -> EnrichmentError

        Args:
            ioc: The IOC to look up. Must be MD5, SHA1, or SHA256.

        Returns:
            EnrichmentResult with verdict "malicious" (found) or "no_data" (not found).
            EnrichmentError on unsupported type, SSRF block, or network failure.
        """
        if ioc.type not in self.supported_types:
            return EnrichmentError(
                ioc=ioc, provider="MalwareBazaar", error="Unsupported type"
            )

        try:
            validate_endpoint(MB_BASE, self._allowed_hosts)
        except ValueError as exc:
            return EnrichmentError(ioc=ioc, provider="MalwareBazaar", error=str(exc))

        try:
            resp = requests.post(
                MB_BASE,
                data={"query": "get_info", "hash": ioc.value},
                timeout=TIMEOUT,           # SEC-04
                allow_redirects=False,     # SEC-06
                stream=True,               # SEC-05 setup
            )
            resp.raise_for_status()
            body = read_limited(resp)     # SEC-05: byte cap enforced
            return self._parse_response(ioc, body)
        except requests.exceptions.Timeout:
            return EnrichmentError(ioc=ioc, provider="MalwareBazaar", error="Timeout")
        except requests.exceptions.HTTPError as exc:
            code = exc.response.status_code if exc.response is not None else "unknown"
            return EnrichmentError(
                ioc=ioc, provider="MalwareBazaar", error=f"HTTP {code}"
            )
        except Exception:
            logger.exception("Unexpected error during MalwareBazaar lookup for %s", ioc.value)
            return EnrichmentError(ioc=ioc, provider="MalwareBazaar", error="Unexpected error during lookup")

    def _parse_response(self, ioc: IOC, body: dict) -> EnrichmentResult:
        """Parse a MalwareBazaar API response into an EnrichmentResult.

        MalwareBazaar uses query_status to indicate result presence.
        If status is "ok", the hash was found (confirmed malware sample).
        If status is "hash_not_found", no record exists.

        For found hashes, extracts: file_type, signature (malware family),
        tags, first_seen, and last_seen from the first data entry.

        Args:
            ioc:  The IOC that was queried.
            body: Parsed JSON from MalwareBazaar API response.

        Returns:
            EnrichmentResult with verdict "malicious" (found) or "no_data" (not found).
        """
        query_status = body.get("query_status", "")

        if query_status == "hash_not_found":
            return EnrichmentResult(
                ioc=ioc,
                provider="MalwareBazaar",
                verdict="no_data",
                detection_count=0,
                total_engines=0,
                scan_date=None,
                raw_stats={},
            )

        # query_status == "ok" — hash found in MalwareBazaar = confirmed malware sample
        data_list = body.get("data", [])
        sample = data_list[0] if data_list else {}

        raw_stats = {
            "file_type": sample.get("file_type"),
            "signature": sample.get("signature"),  # malware family
            "tags": sample.get("tags", []),
            "first_seen": sample.get("first_seen"),
            "last_seen": sample.get("last_seen"),
        }

        return EnrichmentResult(
            ioc=ioc,
            provider="MalwareBazaar",
            verdict="malicious",
            detection_count=1,   # Binary: present in MalwareBazaar = malware
            total_engines=1,     # MalwareBazaar is single-source (present/not)
            scan_date=sample.get("first_seen"),
            raw_stats=raw_stats,
        )
