"""Tests for MalwareBazaar API adapter.

Tests hash lookups, response parsing (found/not-found), error handling,
and all HTTP safety controls (timeout, size cap, no redirects, SSRF allowlist).

All HTTP calls are mocked using unittest.mock.patch — no real API calls.
"""
from __future__ import annotations

import json
from unittest.mock import MagicMock, patch

import pytest
import requests
import requests.exceptions

from app.pipeline.models import IOC, IOCType
from app.enrichment.models import EnrichmentError, EnrichmentResult
from app.enrichment.adapters.malwarebazaar import MBAdapter
from app.enrichment.http_safety import MAX_RESPONSE_BYTES


ALLOWED_HOSTS = ["mb-api.abuse.ch"]

MB_SHA256_FOUND_RESPONSE = {
    "query_status": "ok",
    "data": [
        {
            "sha256_hash": "a" * 64,
            "sha1_hash": "b" * 40,
            "md5_hash": "c" * 32,
            "file_type": "exe",
            "signature": "Emotet",
            "tags": ["exe", "Emotet", "botnet"],
            "first_seen": "2024-01-15 10:00:00",
            "last_seen": "2024-02-01 12:00:00",
        }
    ],
}

MB_NOT_FOUND_RESPONSE = {
    "query_status": "hash_not_found",
    "data": [],
}


def _make_mock_post_response(status_code: int, body: dict | None = None) -> MagicMock:
    """Build a mock requests.Response for POST requests."""
    mock_resp = MagicMock()
    mock_resp.status_code = status_code
    if body is not None:
        raw_bytes = json.dumps(body).encode()
        mock_resp.iter_content = MagicMock(return_value=iter([raw_bytes]))
    if status_code >= 400:
        http_err = requests.exceptions.HTTPError(response=mock_resp)
        mock_resp.raise_for_status = MagicMock(side_effect=http_err)
    else:
        mock_resp.raise_for_status = MagicMock()
    return mock_resp


def _make_adapter(allowed_hosts: list[str] | None = None) -> MBAdapter:
    if allowed_hosts is None:
        allowed_hosts = ALLOWED_HOSTS
    return MBAdapter(allowed_hosts=allowed_hosts)


class TestLookupFound:

    def test_lookup_sha256_found(self) -> None:
        """SHA256 hash found in MalwareBazaar — must return malicious verdict."""
        sha256 = "a" * 64
        ioc = IOC(type=IOCType.SHA256, value=sha256, raw_match=sha256)
        mock_resp = _make_mock_post_response(200, MB_SHA256_FOUND_RESPONSE)

        with patch("requests.post", return_value=mock_resp):
            result = _make_adapter().lookup(ioc)

        assert isinstance(result, EnrichmentResult), (
            f"Expected EnrichmentResult, got {type(result).__name__}: {result!r}"
        )
        assert result.provider == "MalwareBazaar"
        assert result.verdict == "malicious"
        # raw_stats should contain file metadata
        assert "file_type" in result.raw_stats
        assert "signature" in result.raw_stats
        assert "tags" in result.raw_stats
        assert "first_seen" in result.raw_stats
        assert "last_seen" in result.raw_stats

    def test_lookup_md5_found(self) -> None:
        """MD5 hash found in MalwareBazaar — must return malicious verdict."""
        md5 = "c" * 32
        ioc = IOC(type=IOCType.MD5, value=md5, raw_match=md5)
        mock_resp = _make_mock_post_response(200, MB_SHA256_FOUND_RESPONSE)

        with patch("requests.post", return_value=mock_resp):
            result = _make_adapter().lookup(ioc)

        assert isinstance(result, EnrichmentResult)
        assert result.provider == "MalwareBazaar"
        assert result.verdict == "malicious"

    def test_lookup_sha1_found(self) -> None:
        """SHA1 hash found in MalwareBazaar — must return malicious verdict."""
        sha1 = "b" * 40
        ioc = IOC(type=IOCType.SHA1, value=sha1, raw_match=sha1)
        mock_resp = _make_mock_post_response(200, MB_SHA256_FOUND_RESPONSE)

        with patch("requests.post", return_value=mock_resp):
            result = _make_adapter().lookup(ioc)

        assert isinstance(result, EnrichmentResult)
        assert result.verdict == "malicious"


class TestLookupNotFound:

    def test_lookup_not_found(self) -> None:
        """Hash not in MalwareBazaar — must return no_data verdict."""
        sha256 = "f" * 64
        ioc = IOC(type=IOCType.SHA256, value=sha256, raw_match=sha256)
        mock_resp = _make_mock_post_response(200, MB_NOT_FOUND_RESPONSE)

        with patch("requests.post", return_value=mock_resp):
            result = _make_adapter().lookup(ioc)

        assert isinstance(result, EnrichmentResult), (
            f"Expected EnrichmentResult for not-found, got {type(result).__name__}: {result!r}"
        )
        assert result.verdict == "no_data"
        assert result.detection_count == 0
        assert result.total_engines == 0


class TestLookupErrors:

    def test_lookup_unsupported_type_domain(self) -> None:
        """DOMAIN IOC is not a hash — must return EnrichmentError 'Unsupported type'."""
        ioc = IOC(type=IOCType.DOMAIN, value="evil.com", raw_match="evil.com")

        result = _make_adapter().lookup(ioc)

        assert isinstance(result, EnrichmentError)
        assert result.provider == "MalwareBazaar"
        assert "Unsupported" in result.error or "unsupported" in result.error.lower()

    def test_lookup_timeout(self) -> None:
        """Network timeout must return EnrichmentError with 'Timeout' message."""
        sha256 = "a" * 64
        ioc = IOC(type=IOCType.SHA256, value=sha256, raw_match=sha256)

        with patch("requests.post", side_effect=requests.exceptions.Timeout("timed out")):
            result = _make_adapter().lookup(ioc)

        assert isinstance(result, EnrichmentError)
        assert result.provider == "MalwareBazaar"
        assert "Timeout" in result.error or "timeout" in result.error.lower()

    def test_lookup_http_error(self) -> None:
        """HTTP error from MB API must return EnrichmentError."""
        sha256 = "a" * 64
        ioc = IOC(type=IOCType.SHA256, value=sha256, raw_match=sha256)
        mock_resp = _make_mock_post_response(500)

        with patch("requests.post", return_value=mock_resp):
            result = _make_adapter().lookup(ioc)

        assert isinstance(result, EnrichmentError)
        assert result.provider == "MalwareBazaar"

    def test_ssrf_validation(self) -> None:
        """Adapter with empty allowed_hosts must block all outbound calls."""
        sha256 = "a" * 64
        ioc = IOC(type=IOCType.SHA256, value=sha256, raw_match=sha256)

        # Adapter with empty allowlist — should reject ALL outbound requests
        adapter = MBAdapter(allowed_hosts=[])

        with patch("requests.post") as mock_post:
            mock_post.side_effect = AssertionError("Should not reach network")
            result = adapter.lookup(ioc)

        assert isinstance(result, EnrichmentError), (
            "Expected EnrichmentError when host not in allowed_hosts (SSRF check)"
        )
        # Error should mention SSRF or allowed_hosts
        assert "SSRF" in result.error or "allowed" in result.error.lower() or "allowlist" in result.error.lower()


class TestSupportedTypes:

    def test_supported_types(self) -> None:
        """MBAdapter.supported_types must include MD5, SHA1, SHA256 — and NOT DOMAIN/IPV4."""
        assert MBAdapter.supported_types == {IOCType.MD5, IOCType.SHA1, IOCType.SHA256}

    def test_supported_types_excludes_domain(self) -> None:
        """DOMAIN must not be in MBAdapter.supported_types."""
        assert IOCType.DOMAIN not in MBAdapter.supported_types

    def test_supported_types_excludes_ipv4(self) -> None:
        """IPV4 must not be in MBAdapter.supported_types."""
        assert IOCType.IPV4 not in MBAdapter.supported_types


class TestHTTPSafetyControls:

    def test_response_size_limit(self) -> None:
        """SEC-05: Responses exceeding 1 MB must be rejected."""
        sha256 = "a" * 64
        ioc = IOC(type=IOCType.SHA256, value=sha256, raw_match=sha256)

        # Build mock returning oversized response
        oversized_chunk = b"x" * (MAX_RESPONSE_BYTES + 1)
        mock_resp = MagicMock()
        mock_resp.status_code = 200
        mock_resp.raise_for_status = MagicMock()
        mock_resp.iter_content = MagicMock(return_value=iter([oversized_chunk]))

        with patch("requests.post", return_value=mock_resp):
            result = _make_adapter().lookup(ioc)

        assert isinstance(result, EnrichmentError), (
            f"Expected EnrichmentError for oversized response, got {type(result).__name__}"
        )
